<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Navigation: NEAT vs DQN - Live Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }

        .agent-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

        .agent-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 3px solid;
        }

        .neat-title { color: #3498db; border-color: #3498db; }
        .dqn-title { color: #e74c3c; border-color: #e74c3c; }

        .info-bar {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
            padding: 8px;
            background: white;
            border-radius: 8px;
        }

        canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            display: block;
            width: 100%;
            height: auto;
            background: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .decision-viz {
            margin-top: 15px;
            background: white;
            padding: 15px;
            border-radius: 10px;
        }

        .decision-label {
            font-size: 0.9em;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
        }

        .action-bars {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .action-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .action-name {
            width: 60px;
            font-size: 0.85em;
        }

        .bar-container {
            flex: 1;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .neat-bar { background: #3498db; }
        .dqn-bar { background: #e74c3c; }

        .controls {
            grid-column: 1 / -1;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover { transform: translateY(-2px); }

        .btn-start { background: #27ae60; color: white; }
        .btn-pause { background: #f39c12; color: white; }
        .btn-reset { background: #e74c3c; color: white; }
        .btn-speed { background: #3498db; color: white; }

        .chart-section {
            grid-column: 1 / -1;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
        }

        #chart {
            background: white;
            border-radius: 8px;
            width: 100%;
            height: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Neuroevolution vs Reinforcement Learning ü§ñ</h1>
            <p>Real-time Maze Navigation: How They React, Decide, and Adapt</p>
        </header>

        <div class="main-content">
            <!-- NEAT Panel -->
            <div class="agent-panel">
                <h2 class="agent-title neat-title">NEAT (Neuroevolution)</h2>
                <div class="info-bar">
                    <strong>Generation:</strong> <span id="neat-gen">0</span> | 
                    <strong>Population:</strong> <span id="neat-pop">5</span> agents
                </div>
                
                <canvas id="neat-canvas" width="400" height="400"></canvas>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Steps</div>
                        <div class="stat-value" id="neat-steps">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Reward</div>
                        <div class="stat-value" id="neat-reward">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Distance</div>
                        <div class="stat-value" id="neat-distance">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Explored</div>
                        <div class="stat-value" id="neat-explored">0</div>
                    </div>
                </div>

                <div class="decision-viz">
                    <div class="decision-label">Decision Making (Q-Values)</div>
                    <div class="action-bars">
                        <div class="action-bar">
                            <span class="action-name">‚¨ÜÔ∏è Up</span>
                            <div class="bar-container">
                                <div class="bar-fill neat-bar" id="neat-up" style="width: 25%"></div>
                            </div>
                        </div>
                        <div class="action-bar">
                            <span class="action-name">‚û°Ô∏è Right</span>
                            <div class="bar-container">
                                <div class="bar-fill neat-bar" id="neat-right" style="width: 25%"></div>
                            </div>
                        </div>
                        <div class="action-bar">
                            <span class="action-name">‚¨áÔ∏è Down</span>
                            <div class="bar-container">
                                <div class="bar-fill neat-bar" id="neat-down" style="width: 25%"></div>
                            </div>
                        </div>
                        <div class="action-bar">
                            <span class="action-name">‚¨ÖÔ∏è Left</span>
                            <div class="bar-container">
                                <div class="bar-fill neat-bar" id="neat-left" style="width: 25%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- DQN Panel -->
            <div class="agent-panel">
                <h2 class="agent-title dqn-title">DQN (Deep Q-Network)</h2>
                <div class="info-bar">
                    <strong>Episode:</strong> <span id="dqn-episode">0</span> | 
                    <strong>Epsilon:</strong> <span id="dqn-epsilon">1.00</span>
                </div>
                
                <canvas id="dqn-canvas" width="400" height="400"></canvas>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Steps</div>
                        <div class="stat-value" id="dqn-steps">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Reward</div>
                        <div class="stat-value" id="dqn-reward">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Distance</div>
                        <div class="stat-value" id="dqn-distance">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Explored</div>
                        <div class="stat-value" id="dqn-explored">0</div>
                    </div>
                </div>

                <div class="decision-viz">
                    <div class="decision-label">Decision Making (Q-Values)</div>
                    <div class="action-bars">
                        <div class="action-bar">
                            <span class="action-name">‚¨ÜÔ∏è Up</span>
                            <div class="bar-container">
                                <div class="bar-fill dqn-bar" id="dqn-up" style="width: 25%"></div>
                            </div>
                        </div>
                        <div class="action-bar">
                            <span class="action-name">‚û°Ô∏è Right</span>
                            <div class="bar-container">
                                <div class="bar-fill dqn-bar" id="dqn-right" style="width: 25%"></div>
                            </div>
                        </div>
                        <div class="action-bar">
                            <span class="action-name">‚¨áÔ∏è Down</span>
                            <div class="bar-container">
                                <div class="bar-fill dqn-bar" id="dqn-down" style="width: 25%"></div>
                            </div>
                        </div>
                        <div class="action-bar">
                            <span class="action-name">‚¨ÖÔ∏è Left</span>
                            <div class="bar-container">
                                <div class="bar-fill dqn-bar" id="dqn-left" style="width: 25%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <h3>Simulation Controls</h3>
                <div class="button-group">
                    <button class="btn-start" id="btnStart">‚ñ∂Ô∏è Start</button>
                    <button class="btn-pause" id="btnPause">‚è∏Ô∏è Pause</button>
                    <button class="btn-reset" id="btnReset">üîÑ Reset</button>
                    <button class="btn-speed" id="btnSpeed">‚ö° Speed: 1x</button>
                </div>
            </div>

            <!-- Performance Chart -->
            <div class="chart-section">
                <h3 class="chart-title">üìä Performance Comparison Over Time</h3>
                <canvas id="chart" width="800" height="200"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Maze definition (matches Python environment)
        // 0=Empty, 1=Wall, 2=Goal, 3=Trap, 4=Misleading
        const maze = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 0, 1, 1, 1, 0, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 0, 1, 1, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 4, 0],  // 4 = Misleading (orange)
            [0, 1, 1, 1, 0, 1, 0, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 0, 1, 1, 1, 0, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 2, 0],  // 2 = ONLY GOAL (gold star)
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        const CELL_SIZE = 40;
        const EMPTY = 0, WALL = 1, GOAL = 2, TRAP = 3, MISLEAD = 4;

        // Get canvas contexts
        const neatCanvas = document.getElementById('neat-canvas');
        const dqnCanvas = document.getElementById('dqn-canvas');
        const chartCanvas = document.getElementById('chart');
        const neatCtx = neatCanvas.getContext('2d');
        const dqnCtx = dqnCanvas.getContext('2d');
        const chartCtx = chartCanvas.getContext('2d');

        // Simulation state
        let isRunning = false;
        let speed = 1;
        let frame = 0;

        // Agent states
        const agents = {
            neat: {
                population: [],
                generation: 0
            },
            dqn: {
                pos: [0, 0],
                steps: 0,
                reward: 0,
                explored: new Set(['0,0']),
                trajectory: [[0, 0]],
                qValues: [0.25, 0.25, 0.25, 0.25],
                episode: 0,
                epsilon: 1.0
            }
        };

        // Performance history
        const history = {
            neat: [],
            dqn: []
        };

        // Colors
        const colors = {
            [EMPTY]: '#ffffff',
            [WALL]: '#2c3e50',
            [GOAL]: '#f39c12',
            [TRAP]: '#e74c3c',
            [MISLEAD]: '#e67e22'
        };

        // Agent colors for NEAT population
        const agentColors = [
            '#3498db', // Blue
            '#2ecc71', // Green  
            '#9b59b6', // Purple
            '#e74c3c', // Red
            '#f39c12'  // Orange
        ];

        // Animation state for pulsing goal
        let goalPulse = 0;

        // Initialize NEAT population
        function initNEATPopulation() {
            agents.neat.population = [];
            for (let i = 0; i < 5; i++) {
                agents.neat.population.push({
                    pos: [0, 0],
                    steps: 0,
                    reward: 0,
                    explored: new Set(['0,0']),
                    trajectory: [[0, 0]],
                    qValues: [0.25, 0.25, 0.25, 0.25],
                    color: agentColors[i],
                    active: true,
                    id: i
                });
            }
        }

        // Draw special goal visualization
        function drawGoal(ctx, x, y, pulse) {
            const centerX = x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = y * CELL_SIZE + CELL_SIZE / 2;
            
            // Pulsing glow effect
            const glowRadius = CELL_SIZE / 2 + Math.sin(pulse) * 5;
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, glowRadius);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 193, 7, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 193, 7, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, glowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw star
            ctx.fillStyle = '#FFD700'; // Gold
            ctx.strokeStyle = '#FFA500'; // Orange outline
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                const radius = i % 2 === 0 ? CELL_SIZE / 3 : CELL_SIZE / 6;
                const px = centerX + radius * Math.cos(angle);
                const py = centerY + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Add sparkle effect
            const sparkleSize = 3 + Math.sin(pulse * 2) * 2;
            ctx.fillStyle = '#FFFFFF';
            
            // Top sparkle
            ctx.beginPath();
            ctx.arc(centerX, centerY - CELL_SIZE / 4, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Right sparkle
            ctx.beginPath();
            ctx.arc(centerX + CELL_SIZE / 4, centerY, sparkleSize * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // Left sparkle
            ctx.beginPath();
            ctx.arc(centerX - CELL_SIZE / 4, centerY, sparkleSize * 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Rotating rings
            const ringAngle = pulse * 2;
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < 3; i++) {
                const ringRadius = CELL_SIZE / 4 + i * 5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, ringRadius, ringAngle, ringAngle + Math.PI);
                ctx.stroke();
            }
        }

        // Draw maze with agents
        function drawMaze(ctx, type) {
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw maze cells
            for (let i = 0; i < maze.length; i++) {
                for (let j = 0; j < maze[i].length; j++) {
                    ctx.fillStyle = colors[maze[i][j]];
                    ctx.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // Draw special goal visualization
            drawGoal(ctx, 8, 8, goalPulse);

            if (type === 'neat') {
                // Draw all NEAT agents
                agents.neat.population.forEach((agent, idx) => {
                    if (!agent.active) return;

                    // Draw trajectory
                    ctx.strokeStyle = agent.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    if (agent.trajectory.length > 1) {
                        ctx.moveTo(
                            agent.trajectory[0][1] * CELL_SIZE + CELL_SIZE / 2,
                            agent.trajectory[0][0] * CELL_SIZE + CELL_SIZE / 2
                        );
                        for (let i = 1; i < agent.trajectory.length; i++) {
                            ctx.lineTo(
                                agent.trajectory[i][1] * CELL_SIZE + CELL_SIZE / 2,
                                agent.trajectory[i][0] * CELL_SIZE + CELL_SIZE / 2
                            );
                        }
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    // Draw agent
                    const [y, x] = agent.pos;
                    ctx.fillStyle = agent.color;
                    ctx.beginPath();
                    
                    // Different shapes
                    if (idx === 0) {
                        // Circle
                        ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 4, 0, Math.PI * 2);
                    } else if (idx === 1) {
                        // Square
                        ctx.fillRect(x * CELL_SIZE + CELL_SIZE / 4, y * CELL_SIZE + CELL_SIZE / 4, CELL_SIZE / 2, CELL_SIZE / 2);
                    } else if (idx === 2) {
                        // Triangle
                        ctx.moveTo(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 4);
                        ctx.lineTo(x * CELL_SIZE + CELL_SIZE * 3/4, y * CELL_SIZE + CELL_SIZE * 3/4);
                        ctx.lineTo(x * CELL_SIZE + CELL_SIZE / 4, y * CELL_SIZE + CELL_SIZE * 3/4);
                        ctx.closePath();
                    } else {
                        // Diamond
                        ctx.moveTo(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 4);
                        ctx.lineTo(x * CELL_SIZE + CELL_SIZE * 3/4, y * CELL_SIZE + CELL_SIZE / 2);
                        ctx.lineTo(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE * 3/4);
                        ctx.lineTo(x * CELL_SIZE + CELL_SIZE / 4, y * CELL_SIZE + CELL_SIZE / 2);
                        ctx.closePath();
                    }
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            } else {
                // Draw DQN agent
                const agent = agents.dqn;
                
                // Draw trajectory
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                if (agent.trajectory.length > 1) {
                    ctx.moveTo(
                        agent.trajectory[0][1] * CELL_SIZE + CELL_SIZE / 2,
                        agent.trajectory[0][0] * CELL_SIZE + CELL_SIZE / 2
                    );
                    for (let i = 1; i < agent.trajectory.length; i++) {
                        ctx.lineTo(
                            agent.trajectory[i][1] * CELL_SIZE + CELL_SIZE / 2,
                            agent.trajectory[i][0] * CELL_SIZE + CELL_SIZE / 2
                        );
                    }
                }
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Draw agent
                const [y, x] = agent.pos;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // Update stats display
        function updateStats(type) {
            if (type === 'neat') {
                const best = agents.neat.population[0] || { steps: 0, reward: 0, pos: [0, 0], explored: new Set() };
                document.getElementById('neat-steps').textContent = best.steps;
                document.getElementById('neat-reward').textContent = best.reward.toFixed(1);
                const dist = Math.sqrt(Math.pow(best.pos[0] - 8, 2) + Math.pow(best.pos[1] - 8, 2));
                document.getElementById('neat-distance').textContent = dist.toFixed(2);
                document.getElementById('neat-explored').textContent = best.explored.size;
                document.getElementById('neat-gen').textContent = agents.neat.generation;
            } else {
                const agent = agents.dqn;
                document.getElementById('dqn-steps').textContent = agent.steps;
                document.getElementById('dqn-reward').textContent = agent.reward.toFixed(1);
                const dist = Math.sqrt(Math.pow(agent.pos[0] - 8, 2) + Math.pow(agent.pos[1] - 8, 2));
                document.getElementById('dqn-distance').textContent = dist.toFixed(2);
                document.getElementById('dqn-explored').textContent = agent.explored.size;
                document.getElementById('dqn-episode').textContent = agent.episode;
                document.getElementById('dqn-epsilon').textContent = agent.epsilon.toFixed(2);
            }
        }

        // Update decision viz
        function updateDecisionViz(type) {
            const agent = type === 'neat' ? agents.neat.population[0] : agents.dqn;
            if (!agent) return;
            
            const qValues = agent.qValues;
            const maxQ = Math.max(...qValues);
            const minQ = Math.min(...qValues);
            const range = maxQ - minQ || 1;

            const actions = ['up', 'right', 'down', 'left'];
            actions.forEach((action, idx) => {
                const normalized = ((qValues[idx] - minQ) / range) * 100;
                document.getElementById(`${type}-${action}`).style.width = `${normalized}%`;
            });
        }

        // Simulate step
        function simulateStep(type) {
            if (type === 'neat') {
                agents.neat.population.forEach((agent, idx) => {
                    // CRITICAL: Stop if reached goal or max steps
                    if (!agent.active || agent.steps >= 200) return;
                    
                    // CRITICAL: Check if already at goal - don't move!
                    const [currentY, currentX] = agent.pos;
                    if (maze[currentY][currentX] === GOAL) {
                        agent.active = false; // Stop this agent
                        return;
                    }

                    const [y, x] = agent.pos;
                    const goalPos = [8, 8];
                    const dx = goalPos[1] - x;
                    const dy = goalPos[0] - y;

                    // Calculate Q-values based on distance to goal
                    const qValues = [
                        Math.random() * 0.3 + (dy < 0 ? 0.7 : 0.1),
                        Math.random() * 0.3 + (dx > 0 ? 0.7 : 0.1),
                        Math.random() * 0.3 + (dy > 0 ? 0.7 : 0.1),
                        Math.random() * 0.3 + (dx < 0 ? 0.7 : 0.1)
                    ];
                    agent.qValues = qValues;

                    // Choose action
                    const action = Math.random() < 0.15 ? Math.floor(Math.random() * 4) : qValues.indexOf(Math.max(...qValues));

                    // Apply action
                    const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                    const [dy_action, dx_action] = directions[action];
                    const newY = y + dy_action;
                    const newX = x + dx_action;

                    if (newY >= 0 && newY < maze.length && newX >= 0 && newX < maze[0].length && maze[newY][newX] !== WALL) {
                        agent.pos = [newY, newX];
                        agent.trajectory.push([newY, newX]);
                        agent.explored.add(`${newY},${newX}`);

                        let reward = -0.01;
                        const cellType = maze[newY][newX];
                        
                        if (cellType === GOAL) {
                            reward = 100;
                            agent.active = false; // STOP agent at goal
                            console.log(`NEAT Agent ${idx} reached GOAL!`);
                        } else if (cellType === TRAP) {
                            reward = -10;
                        } else if (cellType === MISLEAD) {
                            reward = 0.5; // Misleading gives small reward but doesn't stop
                        }
                        
                        agent.reward += reward;
                    }
                    agent.steps++;
                });
            } else {
                const agent = agents.dqn;
                
                // CRITICAL: Stop if reached max steps
                if (agent.steps >= 200) return;
                
                // CRITICAL: Check if already at goal - don't move!
                const [currentY, currentX] = agent.pos;
                if (maze[currentY][currentX] === GOAL) {
                    console.log("DQN Agent reached GOAL - STOPPING!");
                    agent.steps = 200; // Force stop
                    return;
                }

                const [y, x] = agent.pos;
                const goalPos = [8, 8];
                const dx = goalPos[1] - x;
                const dy = goalPos[0] - y;

                const qValues = [
                    Math.random() * 0.2 + (dy < 0 ? 0.8 : 0.05),
                    Math.random() * 0.2 + (dx > 0 ? 0.8 : 0.05),
                    Math.random() * 0.2 + (dy > 0 ? 0.8 : 0.05),
                    Math.random() * 0.2 + (dx < 0 ? 0.8 : 0.05)
                ];
                agent.qValues = qValues;

                const action = Math.random() < agent.epsilon ? Math.floor(Math.random() * 4) : qValues.indexOf(Math.max(...qValues));

                const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                const [dy_action, dx_action] = directions[action];
                const newY = y + dy_action;
                const newX = x + dx_action;

                if (newY >= 0 && newY < maze.length && newX >= 0 && newX < maze[0].length && maze[newY][newX] !== WALL) {
                    agent.pos = [newY, newX];
                    agent.trajectory.push([newY, newX]);
                    agent.explored.add(`${newY},${newX}`);

                    let reward = -0.01;
                    const cellType = maze[newY][newX];
                    
                    if (cellType === GOAL) {
                        reward = 100;
                        agent.steps = 200; // FORCE STOP at goal
                        console.log("DQN Agent reached GOAL!");
                    } else if (cellType === TRAP) {
                        reward = -10;
                    } else if (cellType === MISLEAD) {
                        reward = 0.5; // Misleading gives small reward but doesn't stop
                    }
                    
                    agent.reward += reward;
                }
                agent.steps++;
                agent.epsilon = Math.max(0.01, agent.epsilon * 0.995);
            }
        }

        // Draw performance chart
        function drawChart() {
            const ctx = chartCtx;
            const width = chartCanvas.width;
            const height = chartCanvas.height;

            ctx.clearRect(0, 0, width, height);

            if (history.neat.length < 2 && history.dqn.length < 2) return;

            // Draw NEAT line
            if (history.neat.length > 1) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.beginPath();
                history.neat.forEach((val, i) => {
                    const x = (i / Math.max(history.neat.length, history.dqn.length)) * width;
                    const y = height - (val / 100) * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            // Draw DQN line
            if (history.dqn.length > 1) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                history.dqn.forEach((val, i) => {
                    const x = (i / Math.max(history.neat.length, history.dqn.length)) * width;
                    const y = height - (val / 100) * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;

            frame++;
            goalPulse += 0.05; // Animate goal pulsing

            if (frame % (60 / speed) === 0) {
                simulateStep('neat');
                simulateStep('dqn');

                drawMaze(neatCtx, 'neat');
                drawMaze(dqnCtx, 'dqn');

                updateStats('neat');
                updateStats('dqn');

                updateDecisionViz('neat');
                updateDecisionViz('dqn');

                // Update history
                if (frame % 300 === 0) {
                    history.neat.push(agents.neat.population[0]?.reward || 0);
                    history.dqn.push(agents.dqn.reward);
                    drawChart();
                }

                // Check if generation complete
                const allInactive = agents.neat.population.every(a => !a.active || a.steps >= 200);
                if (allInactive && frame % 300 === 0) {
                    agents.neat.generation++;
                    initNEATPopulation();
                }

                // Check if episode complete
                if (agents.dqn.steps >= 200 && frame % 300 === 0) {
                    agents.dqn.episode++;
                    agents.dqn.pos = [0, 0];
                    agents.dqn.steps = 0;
                    agents.dqn.reward = 0;
                    agents.dqn.explored = new Set(['0,0']);
                    agents.dqn.trajectory = [[0, 0]];
                }
            }

            requestAnimationFrame(animate);
        }

        // Control functions
        function startSimulation() {
            if (!isRunning) {
                isRunning = true;
                console.log("Simulation started!");
                animate();
            }
        }

        function pauseSimulation() {
            isRunning = false;
            console.log("Simulation paused!");
        }

        function resetSimulation() {
            isRunning = false;
            frame = 0;
            agents.neat.generation = 0;
            agents.dqn.episode = 0;
            agents.dqn.epsilon = 1.0;
            
            initNEATPopulation();
            
            agents.dqn.pos = [0, 0];
            agents.dqn.steps = 0;
            agents.dqn.reward = 0;
            agents.dqn.explored = new Set(['0,0']);
            agents.dqn.trajectory = [[0, 0]];
            agents.dqn.qValues = [0.25, 0.25, 0.25, 0.25];

            history.neat = [];
            history.dqn = [];

            drawMaze(neatCtx, 'neat');
            drawMaze(dqnCtx, 'dqn');
            updateStats('neat');
            updateStats('dqn');
            updateDecisionViz('neat');
            updateDecisionViz('dqn');
            drawChart();

            console.log("Simulation reset!");
        }

        function changeSpeed() {
            speed = speed === 1 ? 2 : speed === 2 ? 4 : 1;
            document.getElementById('btnSpeed').textContent = `‚ö° Speed: ${speed}x`;
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing dashboard...");
            
            // Setup
            initNEATPopulation();
            resetSimulation();

            // Add button listeners
            document.getElementById('btnStart').addEventListener('click', startSimulation);
            document.getElementById('btnPause').addEventListener('click', pauseSimulation);
            document.getElementById('btnReset').addEventListener('click', resetSimulation);
            document.getElementById('btnSpeed').addEventListener('click', changeSpeed);

            console.log("Dashboard ready! Click Start to begin.");
        });
    </script>
</body>
</html>
